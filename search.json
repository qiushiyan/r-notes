[
  {
    "objectID": "loop.html",
    "href": "loop.html",
    "title": "2  Looping and parallel computing",
    "section": "",
    "text": "apply(x, margin, fun) the general function that loop through given dimension of an object\nlapply(x, fun) accepts a list, return a list\nsapply(x, fun, ..., simplify = TRUE, USE.NAMES = TRUE) and vapply(x, fun, FUN.VALUE, ..., USE.NAMES = TRUE), variants of lapply() that produce vectors, matrices, and arrays as output, instead of lists.\n\nsapply() and vapply() are very similar to lapply() except they simplify their output to produce an atomic vector. While sapply() guesses, vapply() takes an additional argument specifying the output type. sapply() is great for interactive use because it saves typing, but if you use it inside your functions you’ll get weird errors if you supply the wrong type of input. vapply() is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions.\n\nsapply(mtcars, class)\n\n      mpg       cyl      disp        hp      drat        wt      qsec        vs \n\"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \n       am      gear      carb \n\"numeric\" \"numeric\" \"numeric\" \n\n# character(1) means each output element should be a length-1 character vector\nvapply(mtcars, class, character(1))\n\n      mpg       cyl      disp        hp      drat        wt      qsec        vs \n\"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"numeric\" \n       am      gear      carb \n\"numeric\" \"numeric\" \"numeric\" \n\n\nIf the function returns results of different types or lengths, sapply() will silently return a list, while vapply() will throw an error. sapply() is fine for interactive use because you’ll normally notice if something goes wrong, but it’s dangerous when writing functions.\n\ntapply(x, group, fun) is a generalisation to apply() that allows for “ragged” arrays, arrays where each row can have a different number of columns. This is often needed when you’re trying to summarise a data set. For example, imagine you’ve collected pulse rate data from a medical trial, and you want to compare the two groups:\n\n\npulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))\ngroup <- rep(c(\"A\", \"B\"), c(10, 12))\n\ntapply(pulse, group, length)\n\n A  B \n10 12 \n\ntapply(pulse, group, mean)\n\n    A     B \n70.00 73.75 \n\n\ntapply() works by creating a “ragged” data structure from a set of inputs, and then applying a function to the individual elements of that structure. The first task is actually what the split() function does. It takes two inputs and returns a list which groups elements together from the first vector according to elements, or categories, from the second vector:\n\nsplit(pulse, group)\n\n$A\n [1] 74 72 67 67 74 70 69 74 65 68\n\n$B\n [1] 75 79 76 74 74 65 76 74 77 72 73 70\n\n\nThen tapply() is just the combination of split() and sapply():\n\ntapply2 <- function(x, group, fun, ...) {\n  pieces <- split(x, group)\n  sapply(pieces, fun, ...)\n}\n\ntapply2(pulse, group, max)\n\n A  B \n74 79 \n\n\nBeing able to rewrite tapply() as a combination of split() and sapply() is a good indication that we’ve identified some useful building blocks."
  },
  {
    "objectID": "loop.html#futureverse",
    "href": "loop.html#futureverse",
    "title": "2  Looping and parallel computing",
    "section": "2.2 Futureverse",
    "text": "2.2 Futureverse\nhttps://henrikbengtsson.github.io/future-tutorial-user2022/index.html"
  },
  {
    "objectID": "flow.html#custom-errors",
    "href": "flow.html#custom-errors",
    "title": "3  Control flow and error handling",
    "section": "3.2 Custom errors",
    "text": "3.2 Custom errors\n\nlibrary(rlang)\n\n\ntryCatch(\n  error = function(cnd) {\n    str(cnd, max.level = 2)\n  },\n  {\n    abort(\n      \"error_not_found\",\n      message = \"Path `blah.csv` not found\",\n      path = \"blah.csv\",\n      format = \"csv\"\n    )\n  }\n)\n\nList of 6\n $ message: chr \"Path `blah.csv` not found\"\n $ trace  :Classes 'rlang_trace', 'rlib_trace', 'tbl' and 'data.frame': 5 obs. of  6 variables:\n  ..$ call       :List of 5\n  ..$ parent     : int [1:5] 0 1 2 3 0\n  ..$ visible    : logi [1:5] FALSE FALSE FALSE FALSE FALSE\n  ..$ namespace  : chr [1:5] \"base\" \"base\" \"base\" \"base\" ...\n  ..$ scope      : chr [1:5] \"::\" \"local\" \"local\" \"local\" ...\n  ..$ error_frame: logi [1:5] FALSE FALSE FALSE FALSE FALSE\n  ..- attr(*, \"version\")= int 2\n $ parent : NULL\n $ path   : chr \"blah.csv\"\n $ format : chr \"csv\"\n $ call   : NULL\n - attr(*, \"class\")= chr [1:4] \"error_not_found\" \"rlang_error\" \"error\" \"condition\"\n\n\nNote the path and format component in the output above, the ... argument in rlang::abort is used to pass metadata about the error.\n\nabort_bad_argument <- function(arg, must, not = NULL) {\n  msg <- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not <- typeof(not)\n    msg <- glue::glue(\"{msg}; not {not}.\")\n  }\n\n  abort(\"error_bad_argument\",\n    message = msg,\n    arg = arg,\n    must = must,\n    not = not\n  )\n}\n\nabort_bad_argument(\"bin\", \"be a positve integer\", not = \"hello\")\n\nError in `abort_bad_argument()`:\n! `bin` must be a positve integer; not character.\n\n\nThe general error_bad_argument helper can be used in any validation context:\n\nmy_log <- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\nmy_log(\"hello\", 2)\n\nError in `abort_bad_argument()`:\n! `x` must be numeric; not character.\n\nmy_log(10, \"hello\")\n\nError in `abort_bad_argument()`:\n! `base` must be numeric; not character.\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n\n[1] \"bad_argument\""
  },
  {
    "objectID": "non-interactive.html",
    "href": "non-interactive.html",
    "title": "7  Non-interactive mode",
    "section": "",
    "text": "https://github.com/gastonstat/tutorial-R-noninteractive"
  },
  {
    "objectID": "non-interactive.html#using-r-cmd",
    "href": "non-interactive.html#using-r-cmd",
    "title": "7  Non-interactive mode",
    "section": "7.1 Using R CMD",
    "text": "7.1 Using R CMD\nR provides an special kind of command called R CMD which should be executed from the command line. This command is an interface or wrapper to various R tools such as processing files in R documentation format, or manipulating add-on packages. These tools are useful in conjunction with R, but not intended to be called “directly”. The main source of reference to know more about R CMD is the R manual An Introduction to R\nThe general form is:\nR CMD command options args\n\ncommand is the name of the tool\noptions are the command line options of R\nargs refers to the arguments passed on to the command\n\nSome of the relevant options for this tutorial are:\n\n--save saves data sets at the end of the R session.\n--no-save does not save data sets at the end of the R session.\n--no-environ don’t read any user file to set environment variables.\n--restore restores .RData file in the directory where R was started\n--vanilla combines --no-save, --no-environ, --no-site-file, --no-init-file and --no-restore\n--quiet, --silent, and -q don’t print out the initial copyright and welcome messages\n--slave makes R run as quietly as possible.\n\n\n7.1.1 R CMD BATCH\nAmong the several available R tools, the one that we are interested in is the BATCH tool, which is designed to run R in batch mode.\nWhen you run R CMD BATCH, the default options are --restore --save\nTo see more information, check the manual documentation by typing ?BATCH (or help(BATCH)) from within an R interactive session. Or by typing R CMD BATCH --help from the command line.\nThe usage is as follows:\nR CMD BATCH options infile outfile\n\noptions are optional options from the command R\ninfile is the required input file with the code to be executed\noutfile is the name of an optional output file. If no output file is provided, the name of infile is taken as default, appending the extension .Rout to it.\n\nIn R/batch-example.R we have\n\n\n\nR/batch-example.R\n\n# Regression analysis of two random vectors\n\n# random data\nx <- rnorm(20)\ny <- x + rnorm(20)\n\n# regression line\nreg <- lm(y ~ x)\n\n# scatter diagram with fitted regression line\npng('scatterplot.png')\nplot(x, y, las = 1, pch = 19, col = \"#555555\")\nabline(reg, col = \"#0000DD59\", lwd = 2)\ndev.off()\n\n# residuals plot\npng('residuals_plot.png')\nplot(x, reg$residuals, las = 1, pch = 19, col = \"#606060\")\nabline(h = 0)\ndev.off()\n\n\nExecute the script via R CMD BATCH\n\nR CMD BATCH --vanilla R/batch-example.R\n\nThe batch-example.Rout file is generated as\n\ncat batch-example.Rout\n\n# R version 4.1.1 (2021-08-10) -- \"Kick Things\"\n# Copyright (C) 2021 The R Foundation for Statistical Computing\n# Platform: aarch64-apple-darwin20 (64-bit)\n\n# R is free software and comes with ABSOLUTELY NO WARRANTY.\n# You are welcome to redistribute it under certain conditions.\n# Type 'license()' or 'licence()' for distribution details.\n\n#   Natural language support but running in an English locale\n\n# R is a collaborative project with many contributors.\n# Type 'contributors()' for more information and\n# 'citation()' on how to cite R or R packages in publications.\n\n# Type 'demo()' for some demos, 'help()' for on-line help, or\n# 'help.start()' for an HTML browser interface to help.\n# Type 'q()' to quit R.\n\n# > # Regression analysis of two random vectors\n# >\n# > # random data\n# > x <- rnorm(20)\n# > y <- x + rnorm(20)\n# >\n# > # regression line\n# > reg <- lm(y ~ x)\n# >\n# > # scatter diagram with fitted regression line\n# > png('scatterplot.png')\n# > plot(x, y, las = 1, pch = 19, col = \"#555555\")\n# > abline(reg, col = \"#0000DD59\", lwd = 2)\n# > dev.off()\n# null device\n#           1\n# >\n# > # residuals plot\n# > png('residuals_plot.png')\n# > plot(x, reg$residuals, las = 1, pch = 19, col = \"#606060\")\n# > abline(h = 0)\n# > dev.off()\n# null device\n#           1\n# >\n# > proc.time()\n#    user  system elapsed\n#   0.084   0.023   0.108\n\nNotice that the R code inside the output file is displayed with the prompt character >.\n\nR CMD BATCH has default options --restore --save --no-readline\n\n--save saves all the objects in the workspace (i.e. all the objects created while the script was executed) into a hidden file .RData which is a file in R’s binary format. When you save the available objects, this is known as saving the image (see help(save) for more information).\n--restore will load the saved images, that is, will load() the content of the file .RData in the directory where R was started.\n--no-readline turns off command-line editing via readline. This option is not that important.\n\nIf you don’t want R CMD BATCH to save the image, use the option --no-save. Likewise, if you don’t want R CMD BATCH to load the objects in .RData use --no-restore.\nYou can further modify the contents of the output file with a couple of additional options:\n\nR CMD BATCH --silent won’t print out the initial copyright and welcome messages.\nR CMD BATCH --no-save won’t save the workspace image (i.e. no .RData will be saved).\nR CMD BATCH --vanilla combines --no-save, --no-environ, --no-site-file, --no-init-file and --no-restore.\n\n\n7.1.1.1 Passing arguments to a script\nIn R/batch-example.R, the number of random values used to create vectors x and y was fixed. However, it would be nice if the user could specify a a value of n to control the length of the random numbers. In other words, it would be nice if we could specify a value for an argument n that we could pass it to the script file.\nWhen running R scripts, often you will want to provide values for certain arguments. Luckily, R CMD BATCH allows you specify arguments and pass them to the script.\nHow to run an R script in batch mode and passing argument? You can pass parameters to scripts via additional arguments on the command line. This is done by quoting the arguments using the --args option:\nR CMD BATCH \"--args arg1 arg2\" myscript.R\nTo receive this command line arguments, the first line in the script would be\n\n# reading arguments\nargs <- commandArgs(TRUE)\nn <- args[1]\n\nHere is how to pass 50 as the first argument\nR CMD BATCH \"--args 50\" myscript.R"
  },
  {
    "objectID": "non-interactive.html#using-rscript",
    "href": "non-interactive.html#using-rscript",
    "title": "7  Non-interactive mode",
    "section": "7.2 Using Rscript",
    "text": "7.2 Using Rscript\nAnother very useful and interesting way to run R in non-interactive mode is the command Rscript. This command is officially referred to as the Scripting Front-End for R because this is an alternative front end originally designed to be used in bash (#!) scripts and other scripting applications.\n\nRscript is the alternative front-end of R CMD BATCH\noutput goes to standard output (stdout)\nRscript has default options --slave --no-restore\n\nIn R, you can check the help documentation with help(Rscript). Also, you can consult the R manual An Introduction to R and read the section Scripting with R\nThe usage of Rscript has the following form:\nRscript [options] [-e expr [-e expr2 ...] | file] [args]\n\noptions are options beginning with double dash --. These can be any of the standard R front-end.\nexpr (further expressions expr2 ...) refers to any R expression, and must be properly quoted\nfile is the name of the input file containing R commands\nargs are arguments to be passed to the script in file\n\n\n7.2.1 Executing simple expressions\nOne basic use of Rscript is to execute simple expressions using the flag -e. For example, to compute the sum 2 + 2, type the following in the command line:\nRscript -e '2 + 2'\nYou can run more than one expression using as many -e flags as expressions to be executed (make sure to properly quote them)\nRscript -e '2 + 3' -e '2 * 3' -e '2 ^ 3'\nYou can also execute a compound expression with multiple commands separated with semicolons ;\nRscript -e '2 + 3; 2 * 3; 2 ^ 3'\n\n\n\n7.2.2 Using Rscript with R script files\nRscript can be used to execute files with R code. If the script file to be run does not require the user to pass arguments, then you can run it in several ways:\nRscript myscript.R\nAnother alternative is to call the source() function via an expression with the -e flag (be careful with the quotes):\nRscript -e 'source(\"myscript.R\")'\nHere’s one example of how to render an .Rmd (R markdown) file from the command line (again, be careful with the quotes):\nRscript -e 'library(rmarkdown); render(\"document.Rmd\")'\nHere’s the same command as above, but now swaping the types of quotes:\nRscript -e \"library(rmarkdown); render('document.Rmd')\""
  },
  {
    "objectID": "non-interactive.html#passing-arguments-to-rscript",
    "href": "non-interactive.html#passing-arguments-to-rscript",
    "title": "7  Non-interactive mode",
    "section": "7.3 Passing arguments to Rscript",
    "text": "7.3 Passing arguments to Rscript\nSome times you want to provide arguments that will be passed to the input file. The way to invoke Rscript and passing arguments is like this:\nRscript script_file.R arg1 arg2\n\nThe main command is Rscript.\nThe name of the input R file is script_file.R\nSupplied arguments are: arg1 and arg2\n\n\n7.3.1 Toy Example: Normal Vector\nConsider the hypothetical example of having a minimalist script normal-vector.R that generates a vector of normal random numbers—via the function rnorm(). This script could look like:\nx <- rnorm(n, mean, sd)\ncat(x)\nIn this case, it would be nice if you can supply values for n, mean, and sd when executing the script. For instance, say you want n to be 100, mean 5, and sd 1.5, you could invoke the script as:\nRscript normal-vector.R 100 5 1.5\n\n\n7.3.2 Extracting Supplied Arguments\nSo how do you access any supplied arguments when calling Rscript from the command line? When you pass arguments to Rscript, these can be retrieved as a character vector with the commandArgs() function. For example, including a line like the one below inside the input file:\nargs <- commandArgs(trailingOnly = TRUE)\ncreates a character vector args that contains the supplied arguments. In other words, commandArgs() extracts the provided command line arguments.\nLet’s take a look at the code in the normal-vector.R example:\n# reading arguments ('n', 'mean', 'sd')\nargs <- commandArgs(trailingOnly = TRUE)\n\nn <- as.numeric(args[1])\nmean <- as.numeric(args[2])\nsd <- as.numeric(args[3])\n\nx <- rnorm(n, mean, sd)\ncat(x, '\\n')\nAs you can tell from the snippet above, commandArgs(TRUE) returns a character vector with the supplied arguments. These values can then be accessed individually (e.g. args[1]). Because the arguments are in the form of a character vector, it’s good practice to convert them into numbers with as.numeric().\n\n\n7.3.3 More about commandArgs()\nThe function commandArgs() takes a logical parameter called trailingOnly. If you use the parameter trailingOnly = FALSE inside commandArgs(), the character vector of arguments will include the default options of calling Rscript. For instance, the file show-args.R in the sripts/ folder consists of the following code:\nargs <- commandArgs(trailingOnly = FALSE)\n\nfor (i in 1:length(args)) {\n    cat(args[i], '\\n')\n}\nwhich will print all the supplied arguments (even the default ones). When you execute show-args.R from the command line without supplying any arguments, you should be able to see an output like the following one:\nRscript show-args.R\n/Library/Frameworks/R.framework/Resources/bin/exec/R\n--slave\n--no-restore\n--file=show-args.R\nas you can tell, the output shows four arguments: the first one refers to the location of the executable R; the other values (--slave, --no-restore, and --file=show-args.R) are the default options when calling Rscript.\n\n\n7.3.4 Excluding default options as arguments\nTo exclude the default (“non-relevant”) arguments, you have to use commandArgs(trailingOnly = TRUE). The scripts/ folder of this tutorial contains the script listing-args.R. This is a simple R script that reads any provided arguments, and displays the number of arguments as well as their values. You can try it like so:\n# no arguments provided\nRscript listing-args.R\n\n# one argument provided\nRscript listing-args.R 10\n\n# various arguments provided\nRscript listing-args.R 1 a TRUE NA yes"
  },
  {
    "objectID": "base-meta.html",
    "href": "base-meta.html",
    "title": "13  Tools in base R",
    "section": "",
    "text": "https://rstudio.github.io/r-manuals/r-lang/Computing-on-the-language.html"
  }
]